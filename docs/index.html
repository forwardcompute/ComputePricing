<script>
(function(){
  // ---------------------- DEBUG LOGGER ----------------------
  const dbg = [];
  function logDbg(msg){
    dbg.push(msg);
    const el = document.getElementById("debugLines");
    if (el) el.innerHTML = dbg.map(s=>`<div>${s}</div>`).join("");
  }
  const dbgToggle = document.getElementById("toggleDebug");
  if (dbgToggle) {
    dbgToggle.addEventListener("change",(e)=>{
      document.getElementById("debugPanel").classList.toggle("on", e.target.checked);
    });
  }

  // ---------------------- UTILS ----------------------
  const fmt = {
    money:n=> n==null||isNaN(n) ? '–' : `$${Number(n).toFixed(2)}`,
    money0:n=> n==null||isNaN(n) ? '–' : `$${Number(n).toFixed(0)}`,
    num:n  => n==null||isNaN(n) ? '–' : Number(n).toLocaleString(),
    date:s => s? String(s).replace('T',' ').replace('Z',''): '–'
  };
  function numify(x){ return x==null ? NaN : Number(String(x).replace(/[^\d.\-]/g,"")); }
  function parseCSV(txt){
    const lines = txt.replace(/^\uFEFF/,'').trim().split(/\r?\n/);
    if (!lines.length) return [];
    const header = lines.shift().split(",").map(h=>h.trim());
    return lines.filter(Boolean).map(line=>{
      const cells = line.split(",").map(s=>s.trim());
      const o={}; header.forEach((h,i)=>o[h]=cells[i]??"");
      return o;
    });
  }
  const uniq = arr => [...new Set(arr)];
  const byNumAsc = key => (a,b)=> (+a[key]||1e12)-(+b[key]||1e12);

  // ---------------------- ROBUST PATHS ----------------------
  async function tryFetch(url){
    const r = await fetch(url,{cache:"no-store"});
    if(!r.ok) throw new Error(r.status+" "+url);
    return r;
  }
  const DER_BASES = [
    "data/derived/","./data/derived/","../data/derived/",
    "docs/data/derived/","./docs/data/derived/","/data/derived/","/docs/data/derived/"
  ];
  async function getDerived(file){
    for(const b of DER_BASES){
      try{ const r=await tryFetch(b+file); logDbg("✅ "+b+file); return r; }catch(e){}
    }
    logDbg("❌ MISSING: "+file); throw new Error("Missing "+file);
  }

  // ---------------------- STATE ----------------------
  const state = {
    scores:[], roi:[], predict:null, snap:[], forecast:[],
    filters: {gpu:"All", region:"All", type:"On-Demand", duration:"All", count:"All"}
  };

  // ---------------------- LOAD DERIVED ----------------------
  const files = {
    scores : "provider_scores_latest.csv",
    roi    : "roi_comparison.csv",
    predict: "price_predict_snapshot.json",
    snap   : "compute_calculator_snapshot.csv",
    forecast: "forecast.csv"
  };

  async function loadAll(){
    try{
      const txt = await (await getDerived(files.scores)).text();
      state.scores = parseCSV(txt).map(r=>({
        provider:r.provider, region:r.region, gpu:r.gpu_model, type:r.type, duration:r.duration,
        count: r.gpu_count ? Number(r.gpu_count) : null,
        price: numify(r.effective_price_usd_per_gpu_hr),
        score: r.priceiq_score ? Number(r.priceiq_score) : null,
        ts: r.timestamp
      })).filter(r=>isFinite(r.price));
      logDbg(`rows(scores): ${state.scores.length}`);
    }catch(e){ logDbg("scores load error: "+e); }

    try{
      const txt = await (await getDerived(files.roi)).text();
      state.roi = parseCSV(txt).map(r=>({
        gpu:r.gpu_model, count:Number(r.gpu_count), duration:r.duration,
        provider:r.best_provider, region:r.best_region,
        p:Number(r.price_per_gpu_hr), total:Number(r.total_cost_usd), ts:r.timestamp
      })).filter(r=>isFinite(r.total));
      logDbg(`rows(roi): ${state.roi.length}`);
    }catch(e){ logDbg("roi load error: "+e); }

    try{ state.predict = await (await getDerived(files.predict)).json(); logDbg("predict: ok"); }
    catch(e){ logDbg("predict not found (ok)"); }

    try{
      const txt = await (await getDerived(files.snap)).text();
      state.snap = parseCSV(txt);
      logDbg(`rows(snapshot): ${state.snap.length}`);
    }catch(e){ logDbg("snapshot load error: "+e); }

    try{
      const txt = await (await getDerived(files.forecast)).text();
      state.forecast = parseCSV(txt).map(r=>({
        gpu:r.gpu_model, region:r.region, type:r.type, duration:r.duration, count:Number(r.gpu_count),
        date:r.date_utc || r.date || r.ts, h:Number(r.horizon_hr || r.h || 0),
        p10:Number(r.p10), p25:Number(r.p25), p50:Number(r.p50), p75:Number(r.p75), p90:Number(r.p90)
      })).filter(r=>r.date && isFinite(r.p50));
      logDbg(`rows(forecast): ${state.forecast.length}`);
    }catch(e){ logDbg("forecast not found (ok)"); }

    initFilters();
    hydrateAll();
    initQuickCalc();
    initBenchmarkUI();
    renderForecast(); // after benchmark init, draw forecast (fallback if needed)
  }

  // ---------------------- FILTERS + KPI ----------------------
  function setOptions(el, arr, withAll=true){
    const vals = withAll ? ["All", ...arr] : arr;
    el.innerHTML = vals.map(v=>`<option>${v}</option>`).join("");
  }

  function initFilters(){
    const gpus = uniq(state.scores.map(r=>r.gpu)).sort();
    const regs = uniq(state.scores.map(r=>r.region)).sort();
    const types= uniq(state.scores.map(r=>r.type)).sort();
    const durs = uniq(state.scores.map(r=>r.duration)).sort();
    const cnts = uniq(state.scores.map(r=>r.count).filter(Boolean)).sort((a,b)=>a-b);

    const gpuSel=document.getElementById("f_gpu");
    const regSel=document.getElementById("f_region");
    const typSel=document.getElementById("f_type");
    const durSel=document.getElementById("f_duration");
    const cntSel=document.getElementById("f_count");

    setOptions(gpuSel,gpus);
    setOptions(regSel,regs);
    setOptions(typSel,types);
    setOptions(durSel,durs);
    setOptions(cntSel,cnts);

    gpuSel.value = gpus.includes("H100") ? "H100" : (gpus[0]||"All");
    typSel.value = types.includes("On-Demand") ? "On-Demand" : "All";
    regSel.value="All"; durSel.value="All"; cntSel.value="All";
    state.filters={gpu:gpuSel.value, region:"All", type:typSel.value, duration:"All", count:"All"};

    [gpuSel,regSel,typSel,durSel,cntSel].forEach((el,i)=>{
      const keys=["gpu","region","type","duration","count"]; const k=keys[i];
      el.addEventListener("change", ()=>{ state.filters[k]=el.value; hydrateAll(); });
    });

    document.getElementById("btnClear").onclick=()=>{
      gpuSel.value = gpus.includes("H100") ? "H100" : (gpus[0]||"All");
      typSel.value = types.includes("On-Demand") ? "On-Demand" : "All";
      regSel.value="All"; durSel.value="All"; cntSel.value="All";
      state.filters={gpu:gpuSel.value, region:"All", type:typSel.value, duration:"All", count:"All"};
      hydrateAll();
    };

    // "Updated" time from latest of any source (scores favored)
    const times = [
      ...state.scores.map(r=>r.ts).filter(Boolean),
      ...state.roi.map(r=>r.ts).filter(Boolean)
    ].sort();
    const latest = times.pop();
    document.getElementById("asOf").textContent = "Updated: " + (latest ? fmt.date(latest) : new Date().toISOString().replace('T',' ').replace('Z',''));
  }

  function applyFilters(rows){
    const f=state.filters;
    return rows.filter(r=>
      (f.gpu==="All"||r.gpu===f.gpu) &&
      (f.region==="All"||r.region===f.region) &&
      (f.type==="All"||r.type===f.type) &&
      (f.duration==="All"||r.duration===f.duration) &&
      (f.count==="All"|| String(r.count)===String(f.count))
    );
  }

  function hydrateAll(){
    const rows=applyFilters(state.scores).sort(byNumAsc("price"));
    document.getElementById("kpi_rows").textContent = rows.length;

    if(rows.length){
      const lo=rows[0];
      document.getElementById("kpi_low").textContent=fmt.money(lo.price);
      document.getElementById("kpi_low_sub").textContent=`${lo.provider} · ${lo.region} · ${lo.gpu} (${lo.type})`;
      const prices=rows.map(r=>r.price).filter(isFinite).sort((a,b)=>a-b);
      const mid=prices[Math.floor(prices.length/2)];
      document.getElementById("kpi_med").textContent=fmt.money(mid);
      document.getElementById("kpi_med_sub").textContent=`${rows.length} quotes`;
      document.getElementById("kpi_prov").textContent=uniq(rows.map(r=>r.provider)).length;
    }else{
      ["kpi_low","kpi_med","kpi_prov"].forEach(id=>document.getElementById(id).textContent="–");
      document.getElementById("kpi_low_sub").textContent="";
      document.getElementById("kpi_med_sub").textContent="";
    }

    // Leaderboard
    document.querySelector("#tbl_leader tbody").innerHTML = rows.map(r=>`
      <tr>
        <td>${r.provider}</td><td>${r.region}</td><td>${r.gpu}</td>
        <td><span class="pill">${r.type}</span></td>
        <td>${r.duration||"–"}</td>
        <td>${r.count!=null? r.count : "–"}</td>
        <td class="right">${fmt.money(r.price)}</td>
        <td class="right">${r.score!=null? Number(r.score).toFixed(1):"–"}</td>
        <td class="right">${fmt.date(r.ts)}</td>
      </tr>`).join("");

    // ROI (cleaner)
    const roi = [...state.roi].filter(r=>isFinite(r.total));
    roi.sort((a,b)=> a.total - b.total);
    const minT = roi.length ? roi[0].total : 0;
    const maxT = roi.length ? roi[roi.length-1].total : 1;
    const span  = Math.max(1, maxT - minT);
    document.getElementById("roiMeta").textContent = roi.length ? `sorted by total cost ↑ · ${roi.length} rows` : "no rows";
    document.querySelector("#tbl_roi tbody").innerHTML = roi.map((r,i)=>{
      const w = Math.max(6, Math.round(((r.total - minT)/span) * 100));
      const best = i===0 ? `<span class="badge best">best</span>` : "";
      return `<tr title="relative vs cheapest: ${w}%">
        <td>${r.gpu}</td><td>${r.count}</td><td>${r.duration}</td>
        <td>${r.provider} ${best}</td><td>${r.region}</td>
        <td class="right">${fmt.money(r.p)}</td>
        <td class="right">
          ${fmt.money0(r.total)}
          <div class="barWrap"><div class="bar" style="width:${w}%"></div></div>
        </td>
      </tr>`;
    }).join("");

    // Snapshot table
    const cbody=document.querySelector("#tbl_comp tbody");
    cbody.innerHTML = state.snap.map(r=>{
      const lo = r.price_lo ?? r.price_lo_usd ?? r.lo;
      const md = r.price_md ?? r.price_md_usd ?? r.md;
      const hi = r.price_hi ?? r.price_hi_usd ?? r.hi;
      return `<tr>
        <td>${r.gpu_model || r.gpu || ""}</td>
        <td>${r.provider_type || r.provider_type_label || ""}</td>
        <td>${r["$/GPU-hr"] || (lo && hi ? `$${lo}–$${hi}`:"")}</td>
        <td>${r.TOTAL || r.total || ""}</td>
        <td class="right">${lo??""}</td>
        <td class="right">${md??""}</td>
        <td class="right">${hi??""}</td>
        <td class="right">${r.term_hours || r.term_hrs || ""}</td>
        <td class="right">${r.gpu_count || r.gpus || ""}</td>
        <td>${r.used_region || r.region || ""}</td>
        <td class="right">${r.n_quotes || r.quotes || ""}</td>
        <td>${r.source || ""}</td>
      </tr>`;
    }).join("");

    // Pred tiles from snapshot
    const pp = state.predict||{};
    const moneyOrDash = v => (v==null||isNaN(v)) ? "–" : `$${Number(v).toFixed(2)}`;
    document.getElementById("p10").textContent  = moneyOrDash(pp.p10);
    document.getElementById("p25").textContent  = moneyOrDash(pp.p25);
    document.getElementById("p50").textContent  = moneyOrDash(pp.p50);
    document.getElementById("p7590").textContent= `${moneyOrDash(pp.p75||pp.p50)} / ${moneyOrDash(pp.p90)}`;
  }

  // ---------------------- QUICK CALC ----------------------
  function initQuickCalc(){
    const gpus = uniq(state.scores.map(r=>r.gpu)).sort();
    const regs = uniq(state.scores.map(r=>r.region)).sort();

    function set(el, arr){ el.innerHTML = arr.map(v=>`<option>${v}</option>`).join(""); }
    const qc_gpu   = document.getElementById("qc_gpu");
    const qc_region= document.getElementById("qc_region");
    const qc_count = document.getElementById("qc_count");
    const qc_dur   = document.getElementById("qc_dur");

    set(qc_gpu, gpus);
    set(qc_region, regs);
    set(qc_count, [8,16,32,64]);
    set(qc_dur, ["1 hour","1 day","1 week","1 month"]);

    qc_gpu.value   = gpus.includes("H100") ? "H100" : (gpus[0]||"");
    qc_region.value= regs.includes("Global") ? "Global" : (regs[0]||"");
    qc_count.value = "8";
    qc_dur.value   = "1 hour";

    document.getElementById("btnCalc").onclick = runQuickCalc;
    runQuickCalc(); // render once on load
  }

  function durToHours(s){
    const v = String(s||"").toLowerCase();
    if (v.includes("month")) return 24*30;
    if (v.includes("week"))  return 24*7;
    if (v.includes("day"))   return 24;
    return 1; // hour
  }

  function runQuickCalc(){
    const gpu  = document.getElementById("qc_gpu").value;
    let   reg  = document.getElementById("qc_region").value;
    const cnt  = Number(document.getElementById("qc_count").value||0);
    const hrs  = durToHours(document.getElementById("qc_dur").value);
    const usePred = document.getElementById("qc_usePred").checked;

    // Primary: exact region
    let rows = state.scores.filter(r=> r.gpu===gpu && r.region===reg && /On-Demand/i.test(r.type));
    // Fallback to any region for visibility
    if (!rows.length){
      const any = state.scores.find(r=> r.gpu===gpu && /On-Demand/i.test(r.type));
      if (any){ reg = any.region; rows = state.scores.filter(r=> r.gpu===gpu && r.region===reg && /On-Demand/i.test(r.type));
               document.getElementById("qc_region").value = reg; logDbg(`QC: no rows for chosen region, using ${reg}`); }
    }

    const byProv = new Map();
    rows.forEach(r=>{
      const k=r.provider+"|"+r.region;
      const best=byProv.get(k);
      if(!best || r.price<best.price) byProv.set(k,r);
    });

    let out=[...byProv.values()].map(r=>({
      provider:r.provider, region:r.region, price:r.price, total:r.price*cnt*hrs, src:"observed"
    }));

    if(usePred && state.predict && state.predict.gpu_model===gpu && state.predict.region===reg && state.predict.p50){
      out.push({ provider:"Predicted (P50)", region:reg, price:Number(state.predict.p50), total:Number(state.predict.p50)*cnt*hrs, src:"predicted" });
    }

    out.sort((a,b)=>a.total-b.total);
    document.querySelector("#tbl_qc tbody").innerHTML = out.map(r=>`
      <tr>
        <td>${r.provider}</td><td>${r.region}</td>
        <td class="right">${fmt.money(r.price)}</td>
        <td class="right">${fmt.money0(r.total)}</td>
        <td class="right"><span class="badge">${r.src}</span></td>
      </tr>`).join("");
  }

  // ---------------------- PERMALINK HELPERS (Benchmark state) ----------------------
  function syncURLFromBenchmark(){
    const params = new URLSearchParams(location.search);
    params.set('gpu',      document.getElementById('bm_gpu').value);
    params.set('region',   document.getElementById('bm_region').value);
    params.set('type',     document.getElementById('bm_type').value);
    params.set('duration', document.getElementById('bm_duration').value);
    params.set('count',    document.getElementById('bm_count').value);
    const qs = params.toString();
    history.replaceState(null, '', qs ? ('?'+qs) : location.pathname);
  }
  function applyURLToBenchmark(){
    const sp = new URLSearchParams(location.search);
    return {
      gpu:      sp.get('gpu')      || null,
      region:   sp.get('region')   || null,
      type:     sp.get('type')     || null,
      duration: sp.get('duration') || null,
      count:    sp.get('count')    || null
    };
  }

  // ---------------------- PRICE BENCHMARK (w/ Confidence + Deal) ----------------------
  function setOptionsPlain(el, arr){ el.innerHTML = arr.map(v=>`<option>${v}</option>`).join(""); }

  let _bmChart;
  function initBenchmarkUI(){
    const rows = state.scores;
    const gpus   = [...new Set(rows.map(r=>r.gpu))].sort();
    const regions= [...new Set(rows.map(r=>r.region))].sort();
    const types  = [...new Set(rows.map(r=>r.type))].sort();
    const durs   = [...new Set(rows.map(r=>r.duration))].sort();
    const counts = [...new Set(rows.map(r=>r.count).filter(Boolean))].sort((a,b)=>a-b);

    setOptionsPlain(document.getElementById("bm_gpu"),     gpus.length?gpus:["H100","H200"]);
    setOptionsPlain(document.getElementById("bm_region"),  regions);
    setOptionsPlain(document.getElementById("bm_type"),    types);
    setOptionsPlain(document.getElementById("bm_duration"),durs);
    setOptionsPlain(document.getElementById("bm_count"),   counts);

    // Apply URL params if present, else sensible defaults
    const u = applyURLToBenchmark();
    document.getElementById("bm_gpu").value      = (u.gpu && gpus.includes(u.gpu)) ? u.gpu : (gpus.includes("H100")?"H100":(gpus[0]||""));
    document.getElementById("bm_region").value   = (u.region && regions.includes(u.region)) ? u.region : (regions.includes("Global")?"Global":(regions[0]||""));
    document.getElementById("bm_type").value     = (u.type && types.includes(u.type)) ? u.type : (types.find(t=>/On-Demand/i.test(t)) || (types[0]||""));
    document.getElementById("bm_duration").value = (u.duration && durs.includes(u.duration)) ? u.duration : (durs.find(d=>/1h|1 hour/i.test(d)) || (durs[0]||""));
    document.getElementById("bm_count").value    = (u.count && counts.includes(+u.count)) ? +u.count : (counts.includes(8)?8:(counts[0]||""));

    document.getElementById("bm_run").onclick = ()=>{ runBenchmark(); renderForecast(); syncURLFromBenchmark(); };
    ["bm_gpu","bm_region","bm_type","bm_duration","bm_count"].forEach(id=>{
      document.getElementById(id).addEventListener("change", ()=>{ runBenchmark(); renderForecast(); syncURLFromBenchmark(); });
    });

    runBenchmark();
    syncURLFromBenchmark();
  }

  function runBenchmark(){
    const gpu  = document.getElementById("bm_gpu").value;
    const reg0 = document.getElementById("bm_region").value;
    const typ0 = document.getElementById("bm_type").value;
    const dur0 = document.getElementById("bm_duration").value;
    const cnt0 = document.getElementById("bm_count").value;

    // Build a sample; relax progressively for coverage
    let sample = state.scores.filter(r=> r.gpu===gpu && r.region===reg0 && r.type===typ0 && r.duration===dur0 && String(r.count)===String(cnt0));
    let note = `exact slice (${sample.length})`;
    if (sample.length < 8) { sample = state.scores.filter(r=> r.gpu===gpu && r.region===reg0 && r.type===typ0 && r.duration===dur0); note="relaxed: drop count"; }
    if (sample.length < 8) { sample = state.scores.filter(r=> r.gpu===gpu && r.region===reg0 && r.type===typ0); note="relaxed: drop duration + count"; }
    if (sample.length < 8) { sample = state.scores.filter(r=> r.gpu===gpu && r.type===typ0); note="relaxed: drop region + duration + count"; }
    if (sample.length < 8) { sample = state.scores.filter(r=> r.gpu===gpu); note="relaxed: GPU only"; }

    const vals = sample.map(r=>r.price).filter(Number.isFinite).sort((a,b)=>a-b);
    const money = n => isFinite(n) ? `$${n.toFixed(2)}` : "–";

    // Quantiles
    const q = (ps)=>{
      const n=vals.length; if(!n) return ps.map(()=>NaN);
      return ps.map(p=>{
        if (n===1) return vals[0];
        const idx=(n-1)*p, lo=Math.floor(idx), hi=Math.ceil(idx);
        if (lo===hi) return vals[lo];
        const w=idx-lo; return vals[lo]*(1-w)+vals[hi]*w;
      });
    };
    const [p10,p25,p50,p75,p90] = q([0.10,0.25,0.50,0.75,0.90]);

    document.getElementById("bm_p10").textContent = money(p10);
    document.getElementById("bm_p25").textContent = money(p25);
    document.getElementById("bm_p50").textContent = money(p50);
    document.getElementById("bm_p75").textContent = money(p75);
    document.getElementById("bm_p90").textContent = money(p90);
    document.getElementById("bm_big").textContent = money(p50);

    // Confidence badge text (in bm_note)
    let noteTxt = `Samples: ${vals.length} (${note})`;
    let conf = "Low";
    if (isFinite(p50) && isFinite(p25) && isFinite(p75) && vals.length){
      const iqr = Math.max(0, p75 - p25);
      const disp = iqr / Math.max(p50, 1e-9);
      conf = (vals.length>=40 && disp<0.25) ? "High" :
             (vals.length>=20 && disp<0.40) ? "Medium" : "Low";
      noteTxt += ` · Confidence: ${conf}`;
    }
    document.getElementById("bm_note").textContent = noteTxt;

    // Deal guidance vs cheapest observed in the sample
    const dealEl = document.getElementById("bm_deal");
    if (dealEl){
      dealEl.style.display = "none";
      dealEl.className = "badge";
      if (vals.length && isFinite(p25) && isFinite(p75)){
        const cheapest = vals[0];
        if (cheapest < p25){
          dealEl.textContent = "Deal (book now)";
          dealEl.classList.add("ok");
          dealEl.style.display = "inline-block";
        } else if (cheapest > p75){
          dealEl.textContent = "Rich (likely cheaper later)";
          dealEl.classList.add("rich");
          dealEl.style.display = "inline-block";
        } else {
          dealEl.textContent = "Fair";
          dealEl.classList.add("warn");
          dealEl.style.display = "inline-block";
        }
      }
    }

    // KDE chart
    const kde = (values, gridN=160)=>{
      const n=values.length; if(!n) return {x:[],y:[]};
      const mean = values.reduce((a,b)=>a+b,0)/n;
      const s2 = values.reduce((a,b)=>a+(b-mean)**2,0)/Math.max(1,n-1);
      const sd = Math.sqrt(Math.max(s2, 1e-9));
      const h = 1.06*sd*Math.pow(n,-1/5);
      const minV = Math.min(...values), maxV = Math.max(...values);
      const pad = 0.15*(maxV-minV || 1);
      const lo = minV - pad, hi = maxV + pad;
      const x = Array.from({length:gridN},(_,i)=> lo + (i/(gridN-1))*(hi-lo));
      const y = x.map(xi=>{
        let s=0; for(const v of values){ const u=(xi-v)/h; s += Math.exp(-0.5*u*u); }
        return s/(n*h*Math.sqrt(2*Math.PI));
      });
      const ymax = Math.max(...y, 1e-9);
      return {x, y:y.map(d=>d/ymax)};
    };
    const {x, y} = kde(vals);
    const ctx = document.getElementById("bm_chart").getContext("2d");
    if (window._bmChart) window._bmChart.destroy();
    if (window.Chart){
      window._bmChart = new Chart(ctx,{
        type:'line',
        data:{ labels: x, datasets:[{label:'Normalized Price Distribution', data:y, fill:true, tension:0.35, pointRadius:0, borderWidth:2}]},
        options:{
          responsive:true,
          plugins:{ legend:{display:true}},
          scales:{
            y:{ min:0, max:1, ticks:{ callback:v=>v.toFixed(1)}},
            x:{ ticks:{ callback:(v)=>'$'+Number(x[v]).toFixed(2), autoSkip:true, maxRotation:0 } }
          },
          interaction:{ mode:'index', intersect:false }
        }
      });
    }
  }

  // ---------------------- FORECAST (72h) ----------------------
  let _fcChart;
  function renderForecast(){
    const fc = state.forecast||[];
    const noteEl = document.getElementById("fcNote");
    const metaEl = document.getElementById("fcMeta");
    if (!fc.length){
      noteEl.textContent = "No forecast.csv found or no rows. Add it via the training step.";
      if (_fcChart){ _fcChart.destroy(); _fcChart=null; }
      return;
    }

    // Try to match benchmark controls; else fall back to first slice in file
    const gpuSel = document.getElementById("bm_gpu")?.value;
    const regSel = document.getElementById("bm_region")?.value;
    const typSel = document.getElementById("bm_type")?.value;
    const durSel = document.getElementById("bm_duration")?.value;
    const cntSel = Number(document.getElementById("bm_count")?.value);

    let rows = fc.filter(r=> r.gpu===gpuSel && r.region===regSel && r.type===typSel && r.duration===durSel && r.count===cntSel);
    let used = {gpu:gpuSel, region:regSel, type:typSel, duration:durSel, count:cntSel, matched:true};
    if (!rows.length){
      rows = fc.slice(); // take whatever is there
      used = {gpu:fc[0].gpu, region:fc[0].region, type:fc[0].type, duration:fc[0].duration, count:fc[0].count, matched:false};
    }
    rows.sort((a,b)=> new Date(a.date) - new Date(b.date));

    const labels = rows.map(r=>{
      const d = new Date(r.date);
      const mm = d.toLocaleString(undefined,{month:'short'});
      const dd = d.getDate();
      const hh = String(d.getHours()).padStart(2,'0');
      return `${mm} ${dd} ${hh}:00`;
    });
    const p10 = rows.map(r=>r.p10);
    const p50 = rows.map(r=>r.p50);
    const p90 = rows.map(r=>r.p90);

    const ctx = document.getElementById("fc_chart").getContext("2d");
    if (_fcChart) _fcChart.destroy();
    if (window.Chart){
      // Band fill between p10 and p90 by stacking datasets
      _fcChart = new Chart(ctx,{
        type:'line',
        data:{
          labels,
          datasets:[
            {label:'P10', data:p10, pointRadius:0, borderWidth:1, tension:0.25, fill:false, hidden:true},
            {label:'P10–P90 band', data:p90, pointRadius:0, borderWidth:0, tension:0.25, fill:{target:0}}, // fills to dataset 0 (P10)
            {label:'P50', data:p50, pointRadius:0, borderWidth:2, tension:0.25}
          ]
        },
        options:{
          responsive:true,
          plugins:{ legend:{display:true}},
          scales:{
            y:{ ticks:{ callback:v=>"$"+Number(v).toFixed(2)}},
            x:{ ticks:{ autoSkip:true, maxRotation:0 }}
          },
          interaction:{ mode:'index', intersect:false }
        }
      });
    }

    metaEl.textContent = `${used.gpu} · ${used.region} · ${used.type} · ${used.duration} · ${used.count} GPUs` + (used.matched?"":" (showing available slice)");
    noteEl.textContent = `Points: ${rows.length}. Band shows P10–P90; line shows P50.`;
  }

  // ---------------------- BOOT ----------------------
  loadAll();
})();
</script>





